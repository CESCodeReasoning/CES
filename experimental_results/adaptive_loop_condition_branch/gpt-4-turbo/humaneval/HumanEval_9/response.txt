[REASONING]
The function `rolling_max` is called with the list `[3, 2, 3, 100, 3]`.
Inside the function, a variable `running_max` is initialized to `None` and an empty list `result` is initialized to store the running maximum values.

Iteration 1:
    - The number `3` is processed.
    - Since `running_max` is `None`, it is set to `3`.
    - The `result` list now contains `[3]`.

Iteration 2:
    - The number `2` is processed.
    - `running_max` is not `None`, so it compares `2` with the current `running_max` (`3`).
    - `running_max` remains `3` as `3` is greater than `2`.
    - The `result` list is updated to `[3, 3]`.

Iteration 3:
    - The number `3` is processed.
    - `running_max` compares `3` with `3`.
    - `running_max` remains `3`.
    - The `result` list is updated to `[3, 3, 3]`.

Iteration 4:
    - The number `100` is processed.
    - `running_max` compares `100` with `3`.
    - `running_max` is updated to `100` as `100` is greater than `3`.
    - The `result` list is updated to `[3, 3, 3, 100]`.

Iteration 5:
    - The number `3` is processed.
    - `running_max` compares `3` with `100`.
    - `running_max` remains `100`.
    - The `result` list is updated to `[3, 3, 3, 100, 100]`.

Finally, the function returns the list `[3, 3, 3, 100, 100]` which represents the running maximum values for each element in the input list.
[/REASONING]

[PYTHON]
from typing import *
def rolling_max(numbers: List[int]) -> List[int]:
    running_max = None
    result = []

    for n in numbers: ## [STATE]n=[3, 2, 3, 100, 3][/STATE][STATE]numbers=[3, 2, 3, 100, 3][/STATE]
        if running_max is None: ## [CONDITION](running_max is None)=[True, False, False, False, False][/CONDITION][BRANCH]taken=[Y, N, N, N, N][/BRANCH]
            running_max = n
        else: ## [BRANCH]taken=[N, Y, Y, Y, Y][/BRANCH]
            running_max = max(running_max, n)

        result.append(running_max)

    return result
[/PYTHON]

[OUTPUT]
[3, 3, 3, 100, 100]
[/OUTPUT]