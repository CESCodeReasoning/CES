
[REASONING]
The function `rolling_max` is called with ( numbers = [1, 2, 3, 4] ).
Inside the function, a variable `running_max` is initialized to None and an empty list `result` is created.

Iteration 1:
    - `running_max` is None, so `n` (1) is assigned to `running_max`.
    - `running_max` (1) is appended to `result`.
Iteration 2:
    - `running_max` (1) is not None, so `running_max` is updated to the maximum of `running_max` (1) and `n` (2).
    - `running_max` (2) is appended to `result`.
Iteration 3:
    - `running_max` (2) is not None, so `running_max` is updated to the maximum of `running_max` (2) and `n` (3).
    - `running_max` (3) is appended to `result`.
Iteration 4:
    - `running_max` (3) is not None, so `running_max` is updated to the maximum of `running_max` (3) and `n` (4).
    - `running_max` (4) is appended to `result`.

Therefore, the final output of the function `rolling_max([1, 2, 3, 4])` is [1, 2, 3, 4].
[/REASONING]

[ANSWER]
from typing import *


def rolling_max(numbers: List[int]) -> List[int]:
    running_max = None
    result = []

    for n in numbers: ## [STATE]n=[1, 2, 3, 4][/STATE][STATE]numbers=[[1, 2, 3, 4]][/STATE]
        if running_max is None: ## [CONDITION](running_max is None)=[Y, N, N, N][/CONDITION][BRANCH]taken=[Y, N, N, N][/BRANCH]
            running_max = n
        else: ## [BRANCH]taken=[N, Y, Y, Y][/BRANCH]
            running_max = max(running_max, n)

        result.append(running_max)

    return result
[/ANSWER]

[OUTPUT]
[1, 2, 3, 4]
[/OUTPUT]
