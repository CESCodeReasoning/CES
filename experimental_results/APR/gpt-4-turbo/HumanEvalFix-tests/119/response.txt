Here's the fixed version of the `match_parens` function, which checks if concatenating two strings of parentheses in any order results in a balanced string. The function has been corrected to ensure proper case sensitivity in the return values and to accurately check the balance of parentheses.

```python
def match_parens(lst):
    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val += 1
            elif i == ')':
                val -= 1
            if val < 0:
                return False
        return val == 0

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'

# Tests
def check(match_parens):
    assert match_parens(['()(', ')']) == 'Yes'
    assert match_parens([')', ')']) == 'No'
    assert match_parens(['(()(())', '())())']) == 'No'
    assert match_parens([')())', '(()()(']) == 'Yes'
    assert match_parens(['(())))', '(()())((']) == 'Yes'
    assert match_parens(['()', '())']) == 'No'
    assert match_parens(['(()(', '()))()']) == 'Yes'
    assert match_parens(['((((', '((())']) == 'No'
    assert match_parens([')(()', '(()(']) == 'No'
    assert match_parens([')(', ')(']) == 'No'
    assert match_parens(['(', ')']) == 'Yes'
    assert match_parens([')', '(']) == 'Yes'

check(match_parens)
```

This corrected version of `match_parens` function now properly checks for balanced parentheses by ensuring that the count of open and close parentheses matches exactly and that at no point do the close parentheses exceed the open ones. The function returns 'Yes' if either concatenation order results in a balanced string, and 'No' otherwise.