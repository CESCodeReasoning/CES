Here are the fixed versions of the two functions `has_close_elements` and `sort_even`:

### Fixed Code for `has_close_elements`
```python
from typing import List

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True
    return False
```

### Fixed Code for `sort_even`
```python
def sort_even(l: list):
    evens = l[::2]
    evens.sort()
    odds = l[1::2]
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
```

These fixes address the issues in the original code:
1. In `has_close_elements`, the distance calculation now correctly uses the absolute value to ensure it checks the correct proximity regardless of the order of subtraction.
2. In `sort_even`, the even-indexed elements are sorted correctly, and the list is reconstructed by interleaving the sorted even-indexed elements with the original odd-indexed elements. The condition to append the last even-indexed element if there are more evens than odds is also correctly handled.