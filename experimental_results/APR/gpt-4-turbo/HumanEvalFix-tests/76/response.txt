Here are the fixed versions of the two functions `has_close_elements` and `is_simple_power`:

### Fixed Code for `has_close_elements`
```python
from typing import List

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True
    return False
```

### Fixed Code for `is_simple_power`
```python
def is_simple_power(x, n):
    if n == 1:
        return x == 1
    power = 1
    while power < x:
        power *= n
    return power == x
```

### Explanation of Fixes

#### `has_close_elements`
- The main issue was the lack of absolute value in calculating the distance between two elements. This could lead to negative distances which would not correctly evaluate the threshold condition. Using `abs()` ensures that the distance is always non-negative.

#### `is_simple_power`
- The condition in the while loop was incorrect (`while (n < x):`). It should be `while (power < x):` to correctly multiply `n` until `power` reaches or exceeds `x`.
- The loop was missing an increment step. It should multiply `power` by `n` in each iteration (`power = power * n`).
- The condition `if (n == 1): return (x == 1)` correctly handles the edge case where `n` is 1. The function should return `True` only if `x` is also 1, which is correctly implemented.