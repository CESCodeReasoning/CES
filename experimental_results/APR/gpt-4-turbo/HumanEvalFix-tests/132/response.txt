Here are the fixed versions of the two functions `has_close_elements` and `is_nested` based on the provided specifications and test cases:

### Fixed Code for `has_close_elements`

```python
from typing import List

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)  # Use absolute value to measure distance correctly
                if distance < threshold:
                    return True
    return False
```

### Fixed Code for `is_nested`

```python
def is_nested(string):
    balance = 0
    max_depth = 0
    for char in string:
        if char == '[':
            balance += 1
            max_depth = max(max_depth, balance)  # Track maximum depth of nesting
        elif char == ']':
            if balance == 0:
                return False  # More closing brackets than opening
            balance -= 1
    return max_depth > 1 and balance == 0  # True if max depth is more than 1 and all brackets are closed
```

These fixes address the issues in the original code:
- For `has_close_elements`, the distance calculation now correctly uses the absolute value to ensure that the function checks for closeness correctly regardless of the order of subtraction.
- For `is_nested`, the function now correctly checks for nested brackets by tracking the balance of opening and closing brackets and ensuring that the maximum depth of nesting is greater than 1, indicating at least one set of nested brackets. It also ensures that all brackets are matched by checking if the balance is zero at the end.