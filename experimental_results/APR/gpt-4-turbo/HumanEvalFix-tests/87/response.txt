Here is the fixed code for both functions, `has_close_elements` and `get_row`, with the necessary corrections and improvements:

### Fixed Code for `has_close_elements`
```python
from typing import List

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True
    return False
```

### Fixed Code for `get_row`
```python
def get_row(lst, x):
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(coords, key=lambda coord: (coord[0], -coord[1]))
```

### Explanation of Fixes

1. **has_close_elements**:
   - The main issue was the lack of absolute value in calculating the distance between elements. This has been corrected by using `abs(elem - elem2)` to ensure the distance is always non-negative.

2. **get_row**:
   - The original code had a complex and incorrect sorting mechanism. The requirement is to sort primarily by rows in ascending order and then by columns in descending order within each row. This has been simplified and corrected to `sorted(coords, key=lambda coord: (coord[0], -coord[1]))`, which sorts by row ascending and column descending directly.

These fixes ensure that the functions behave as expected based on the provided test cases and specifications.