Here is the fixed code for both functions, `has_close_elements` and `make_palindrome`, with the necessary corrections and improvements:

### Fixed Code for `has_close_elements`
```python
from typing import List

def has_close_elements(numbers: List[float], threshold: float) -> bool:
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)  # Use absolute value to measure distance correctly
                if distance < threshold:
                    return True
    return False
```

### Fixed Code for `make_palindrome`
```python
def is_palindrome(string: str) -> bool:
    """ Test if given string is a palindrome """
    return string == string[::-1]

def make_palindrome(string: str) -> str:
    if not string:
        return ''

    # Find the longest palindromic suffix
    for i in range(len(string)):
        if is_palindrome(string[i:]):
            return string + string[:i][::-1]

    return string  # This line is technically unreachable due to the logic above
```

These fixes address the issues in the original code:
- For `has_close_elements`, the use of `abs` ensures that the distance is always a non-negative value, which is crucial for comparing distances correctly.
- For `make_palindrome`, the loop now correctly identifies the longest palindromic suffix and appends the reverse of the prefix before this suffix to the original string to form the shortest palindrome starting with the given string.